- when breakpoint() API is called in the code the execution is paused reaching this code and connected debugger is openned.
- In the pdb prompt, regular debugging commands can be used. List of commands


		- s(tep)
		Execute the current line, stop at the first possible occasion (either in a function that is called or on the next line in the current function).

		- n(ext)
		Continue execution until the next line in the current function is reached or it returns. (The difference between next and step is that step stops inside a called function, while next executes called functions at (nearly) full speed, only stopping at the next line in the current function.)

		- unt(il) [lineno]
		Without argument, continue execution until the line with a number greater than the current one is reached.
		With lineno, continue execution until a line with a number greater or equal to lineno is reached. In both cases, also stop when the current frame returns.

		- r(eturn)
		Continue execution until the current function returns.

		- c(ont(inue))
		Continue execution, only stop when a breakpoint is encountered.

		- j(ump) lineno
		Set the next line that will be executed. Only available in the bottom-most frame. This lets you jump back and execute code again, or jump forward to skip code that you don’t want to run.
		It should be noted that not all jumps are allowed – for instance it is not possible to jump into the middle of a for loop or out of a finally clause.

		- l(ist) [first[, last]]
		List source code for the current file. Without arguments, list 11 lines around the current line or continue the previous listing. With . as argument, list 11 lines around the current line. With one argument, list 11 lines around at that line. With two arguments, list the given range; if the second argument is less than the first, it is interpreted as a count.

		The current line in the current frame is indicated by ->. If an exception is being debugged, the line where the exception was originally raised or propagated is indicated by >>, if it differs from the current line.

		ll | longlist
		List all source code for the current function or frame. Interesting lines are marked as for list.

		New in version 3.2.

		a(rgs)
		Print the arguments of the current function and their current values.

		p expression
		Evaluate expression in the current context and print its value.

		Note print() can also be used, but is not a debugger command — this executes the Python print() function.
		pp expression
		Like the p command, except the value of expression is pretty-printed using the pprint module.

		whatis expression
		Print the type of expression.

		source expression
		Try to get source code of expression and display it.

		New in version 3.2.

		display [expression]
		Display the value of expression if it changed, each time execution stops in the current frame.

		Without expression, list all display expressions for the current frame.

		Note Display evaluates expression and compares to the result of the previous evaluation of expression, so when the result is mutable, display may not be able to pick up the changes.
		Example:

		lst = []
		breakpoint()
		pass
		lst.append(1)
		print(lst)
		Display won’t realize lst has been changed because the result of evaluation is modified in place by lst.append(1) before being compared:

		> example.py(3)<module>()
		-> pass
		(Pdb) display lst
		display lst: []
		(Pdb) n
		> example.py(4)<module>()
		-> lst.append(1)
		(Pdb) n
		> example.py(5)<module>()
		-> print(lst)
		(Pdb)
		You can do some tricks with copy mechanism to make it work:

		> example.py(3)<module>()
		-> pass
		(Pdb) display lst[:]
		display lst[:]: []
		(Pdb) n
		> example.py(4)<module>()
		-> lst.append(1)
		(Pdb) n
		> example.py(5)<module>()
		-> print(lst)
		display lst[:]: [1]  [old: []]
		(Pdb)
		New in version 3.2.

		undisplay [expression]
		Do not display expression anymore in the current frame. Without expression, clear all display expressions for the current frame.

		New in version 3.2.

		interact
		Start an interactive interpreter (using the code module) whose global namespace contains all the (global and local) names found in the current scope.

		New in version 3.2.

		alias [name [command]]
		Create an alias called name that executes command. The command must not be enclosed in quotes. Replaceable parameters can be indicated by %1, %2, and so on, while %* is replaced by all the parameters. If command is omitted, the current alias for name is shown. If no arguments are given, all aliases are listed.

		Aliases may be nested and can contain anything that can be legally typed at the pdb prompt. Note that internal pdb commands can be overridden by aliases. Such a command is then hidden until the alias is removed. Aliasing is recursively applied to the first word of the command line; all other words in the line are left alone.

		As an example, here are two useful aliases (especially when placed in the .pdbrc file):

		# Print instance variables (usage "pi classInst")
		alias pi for k in %1.__dict__.keys(): print(f"%1.{k} = {%1.__dict__[k]}")
		# Print instance variables in self
		alias ps pi self
		unalias name
		Delete the specified alias name.

		! statement
		Execute the (one-line) statement in the context of the current stack frame. The exclamation point can be omitted unless the first word of the statement resembles a debugger command, e.g.:

		(Pdb) ! n=42
		(Pdb)
		To set a global variable, you can prefix the assignment command with a global statement on the same line, e.g.:

		(Pdb) global list_options; list_options = ['-l']
		(Pdb)
		run [args ...]
		restart [args ...]
		Restart the debugged Python program. If args is supplied, it is split with shlex and the result is used as the new sys.argv. History, breakpoints, actions and debugger options are preserved. restart is an alias for run.

		q(uit)
		Quit from the debugger. The program being executed is aborted.

		debug code
		Enter a recursive debugger that steps through code (which is an arbitrary expression or statement to be executed in the current environment).

		retval
		Print the return value for the last return of the current function.
